# Handlers & aggregation

Handlers are the core of the BFF's value. They are the only layer that **combines data from multiple sources**, **reshapes it for a specific view**, and **tolerates partial failures** without killing the response. Every `/bff/*` route maps to exactly one handler.

## Why aggregation matters

During server-side rendering, the page renderer needs all its data before it can produce HTML. Without a BFF, the SSR code would have to:

1. Make a call to the REST API for the card list.
2. Make a separate call to the GraphQL API for set metadata.
3. Wait for both to complete (or fail) before deciding what to render.
4. Handle the case where one call failed but the other succeeded.

The handler encapsulates all of that. The SSR code makes a single fetch to `/bff/browse` and gets back a complete, view-shaped payload — or a partial one with an `errors` array explaining what's missing.

## Handler contract

Every handler receives the same four arguments and returns a `Response`:

```typescript
type BffHandler = (
  request: Request,
  params: Record<string, string>, // URL path params (e.g. { id: "abc" })
  searchParams: URLSearchParams, // query string
  context: BffContext // { requestId, startTime }
) => Promise<Response>;
```

The `context` object carries a unique request ID (either from an incoming `X-Request-ID` header or generated by the router) and is stamped onto every response for traceability.

## Handler: `getBrowse`

**Route:** `GET /bff/browse`
**File:** `src/server/bff/handlers/browse.ts`
**Downstream:** REST API only

This handler assembles everything the browse page needs in a single response.

### What it fetches

| Data                                   | Source                                         | Notes                                                                   |
| -------------------------------------- | ---------------------------------------------- | ----------------------------------------------------------------------- |
| Card list (paginated)                  | `restApiClient.getCards()` or `.searchCards()` | Which method is called depends on whether any filter params are present |
| Filter options (types, rarities, sets) | `restApiClient.getSets()`                      | Cached for 5 minutes — filter metadata changes infrequently             |

### Error handling strategy

The two fetches are **independent**. Each is wrapped in its own try/catch:

- If the **card fetch** fails, `data.cards` is set to `[]` and `data.pagination` is zeroed out. An error entry is pushed.
- If the **filter fetch** fails, `data.filters` is set to empty arrays. An error entry is pushed.
- The response status is 503 only if cards failed **and** the cards array is empty. If cards succeeded but filters failed, the status is still 200 — the page can render without filter options.

```typescript
// Simplified error handling logic
const response: BffResponse<BrowseData> = { data };
if (errors.length > 0) {
  response.errors = errors; // always include errors if any occurred
}

return new Response(JSON.stringify(response), {
  status: errors.length > 0 && !data.cards?.length ? 503 : 200
});
```

### Data reshaping

The handler strips the raw REST response down to only the fields the browse page renders:

```typescript
data.cards = cardsResponse.data.map((card) => ({
  id: card.id,
  name: card.name,
  supertype: card.supertype,
  types: card.types,
  rarity: card.rarity,
  images: card.images,
  set: card.set ? { id: card.set.id, name: card.set.name } : undefined
}));
```

Fields like `hp`, `attacks`, `abilities`, `evolvesFrom`, and marketplace URLs are present in the upstream response but are not needed on the browse grid. Stripping them reduces the JSON payload sent to the browser.

## Handler: `getCardDetail`

**Route:** `GET /bff/card/:id`
**File:** `src/server/bff/handlers/card.ts`
**Downstream:** GraphQL API only

This handler assembles the card detail page, which needs deep nested data that maps naturally to a GraphQL query.

### What it fetches

| Data                                                   | Source                                   | Notes                                              |
| ------------------------------------------------------ | ---------------------------------------- | -------------------------------------------------- |
| Full card with set, abilities, attacks, weaknesses     | `graphqlClient.getCard(id)`              | Primary fetch — failure is fatal for this endpoint |
| Related cards (same Pokemon name, different printings) | `graphqlClient.getCardsByName(baseName)` | Secondary fetch — failure is non-critical          |

### Error handling strategy

The two fetches are **nested**, not independent, because the related-cards query depends on the card name from the primary fetch:

- If the **primary fetch** fails, the handler returns a 503 immediately. There is nothing useful to render without the card itself.
- If the **related cards fetch** fails, `data.relatedCards` is set to `[]` and a warning is added. The page renders with the card detail but without the "related cards" section.

```typescript
try {
  const cardResult = await graphqlClient.getCard(id);
  // ... set data.card, data.set ...

  try {
    const relatedResult = await graphqlClient.getCardsByName(baseName);
    data.relatedCards = relatedResult.cardsByName
      .filter((c) => c.id !== id)   // exclude the card itself
      .slice(0, 6);                 // cap at 6 related cards
  } catch (error) {
    data.relatedCards = [];
    errors.push({ source: 'graphql', code: 'RELATED_CARDS_FAILED', ... });
  }
} catch (error) {
  return new Response(/* 503 */);   // primary fetch failed — bail out
}
```

### Caching

Successful responses are cached by card ID with a 2-minute TTL:

```typescript
const cacheKey = `bff:card:${id}`;

// Check cache before any fetches
const cached = bffCache.get<CardDetailData>(cacheKey);
if (cached) {
  return new Response(JSON.stringify({ data: cached }), {
    headers: { 'X-Cache': 'HIT' }
  });
}

// ... fetch and assemble ...

// Cache the result
if (data.card) {
  bffCache.set(cacheKey, data, CACHE_TTL);
}
```

The `X-Cache` header on the response tells you whether the data came from cache (`HIT`) or was freshly fetched (`MISS`).

## Handler: `getBffHealth`

**Route:** `GET /bff/health`
**File:** `src/server/bff/handlers/health.ts`
**Downstream:** Both REST API and GraphQL API

This is not a data handler — it is a **health probe**. It calls the `/health` endpoint on the REST API and the `health` GraphQL query, measures latency on each, and returns an aggregate status:

| All healthy                   | Some healthy                   | None healthy                    |
| ----------------------------- | ------------------------------ | ------------------------------- |
| `status: "healthy"`, HTTP 200 | `status: "degraded"`, HTTP 200 | `status: "unhealthy"`, HTTP 503 |

This endpoint is intended for use by load balancers and monitoring systems. The `degraded` status is deliberately not a failure — it means the BFF can still serve some traffic, just not everything.

## Why REST for browse, GraphQL for card detail?

This is a deliberate split based on the shape of the data each view needs:

- **Browse** needs a flat, paginated list of cards with minimal fields. REST's paginated resource model (`/cards?page=2&pageSize=60`) maps directly to this. The REST API is backed by a simple PostgreSQL table scan with `LIMIT`/`OFFSET`.
- **Card detail** needs a single card with deeply nested relationships — set info, abilities, attacks, weaknesses, evolution chains, marketplace links. GraphQL's ability to select exactly the fields needed in a single query and traverse relationships (including Neo4j graph data) makes it the right fit. A REST equivalent would require multiple round-trips or a monolithic response with dozens of unused fields.

The handlers are the **only place** this protocol decision is made. The browser, the proxy, and the typed clients are all protocol-agnostic.
